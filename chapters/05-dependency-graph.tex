\chapter{Dependency Graph}

In questo capitolo si descrive l'algoritmo di costruizione del Dependency Graph nelle sue varie fasi.

\section{Il Grafo}

Il Grafo delle Dipendenze deve essere modellato in modo da essere sovrapponibile a quello prodotto da Arcan.
In questo senso si attua una semplificazione del modello appiattendo la distinzione tra Unit, Container e Module: i nodi saranno distinti dall'attributo defkind che e' stato trattato nei capitoli precedenti.
Per quanto riguarda invece le relazioni, esse saranno all'incirca identiche, seppur con qualche distinzione nel merito delle entita' coinvolte.

Sia $G = (V, E)$ un grafo delle dipendenze, il generico nodo $v \in V$ sara' etichettato con il suo \emph{fully qualified name} e avra' associato il \emph{defkind}.
Quindi il generico arco $e \in E$ sara' etichettato con il nome della relazione che esso rappresenta.

\section{Esempio}

Sia dato il seguente codice d'esempio Java:

\begin{lstlisting}[language=Java]
package unimib.ingsof;

class Animal {
  String name;
  public void eat() {
    System.out.println("I can eat");
  }
}

class Dog extends Animal {
  public void display() {
    System.out.println("My name is " + name);
  }
}

class Main {
  public static void main(String[] args) {
    Dog labrador = new Dog();
    labrador.name = "Rohu";
    labrador.display();
    labrador.eat();
  }
}
\end{lstlisting}

Il procedimento di costruzione presentato in questo capitolo deve essere in grado di costruire il seguente Grafo delle Dipendenze:

\putimage{diagrams/05/depGraphExample.png}{"Esempio di Grafo delle Dipendenze"}{fig:depGraphExample}

In questa immagine le componenti sono renderizzate con Cytoscape.js, una libreria Javascript adatta alla visualizzazione di grafi, in modo da distinguere i nodi in base al \emph{defkind} con forma e colore: quindi per esempio i quadrati rossi sono di tipo Method e gli esagono blu sono di tipo Class.
Si puo' notare come oltre alle reference gia' citate si tiene traccia anche della relazione di parentela \emph{definedBy}, che mette in relazione il codice sorgente contenuto con il contenitore.

\section{Costruzione}

La costruzione avvera' in tre fasi.
Prima di tutto si usa Tree Sitter Stack Graph per costruire lo Stack Graph del codice usando una grammatica costruita con il modello del Capitolo 4.
Quindi si procedera' a risolvere le reference dello Stack Graph: questa operazione e' molto importante in quanto permettera' ad una esplorazione successiva di sostituire immediatamente i nodi di reference delle relazioni con i nodi concreti di definizione e quindi costruire relazioni con i nodi del grafo delle dipendenze giusti.
L'ultimo passo sara' una esplorazione ricorsiva che permettera' di evidenziare tutti i nodi di definizione e costruire le relazioni di parentela e quelle dettate dalle reference.
Al termine dell'operazione sara' necessario poter esportare il grafo per permettere ad ulteriore software di fare elaborazioni successive, come per esempio Arcan.

\paragraph{Analisi del Codice Sorgente}

Il software legge dalla linea di comando una lista di \emph{target}, ovvero la lista dei progetti da analizzare.
Ogni target puo' essere un file singolo o una cartella, nel secondo caso si considereranno tutti i file di essa ricorsivamente.


\begin{lstlisting}[language=Python, caption=pseudocodice]
for target in config.targets:
    

\end{lstlisting}

\paragraph{Risoluzione delle Reference}

%TODO

\paragraph{Esplorazione Ricorsiva}

%TODO

\section{Esportazione}

%TODO
