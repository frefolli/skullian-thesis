\chapter{Stack Graph}

\section{Introduzione}
%TODO: quote
Stack Graph e' un modello di grafo nato per risolvere il problema della navigazione simbolica del codice.
Attraverso la costruzione di un grafo con nodi detti di "scope", "push" e "pop" permette di effettuare una ricerca di una reference fino alla sua definizione.

Questa ricerca e' una vera e propria visita del grafo, che utilizza da una parte un Symbol Stack per tenere traccia dei simboli incontrati nella ricerca, e dall'altra tipi differenti di nodi visitabili che prescrivono come operare sul Symbol Stack e di conseguenza stabilire se un arco e' percorribile e se un percorso e' definito "completo".
Un percorso e' detto tale se e solo se il Symbol Stack e' svuotato.

Un nodo "push" inserisce un simbolo nel Symbol Stack quando e' attraversato dalla visita.
Vice versa un nodo "pop" rimuove un simbolo dal Symbol Stack.
In particolare questo limita gli archi percorribili in base a se e' possibile rimuovere il simbolo del nodo "pop".

\section{Esempio}
%TODO: esempio stupido del programma Java del capitolo precedente

\section{In Rust}
%TODO: codice per caricare la TSG e usare Stack Graph

\section{Domain Specific Language}

%TODO: quote
La libreria \textbf{Tree Sitter Stack Graph} funge da query engine per il Query Language definito da Tree Sitter e permette attraverso un linguaggio di scripting di costruire a runtime un grafo di tipo Stack Graph a partire da un file analizzato con Tree Sitter.

\paragraph{sintassi}

\begin{verbatim}
(tagA) {
    ;; code
}
\end{verbatim}

%TODO: quote
Ad ogni query tree sitter si accompagna un blocco di codice.
Un insieme di unita' siffatte e di dichiarazioni globali costituisce quella che in gergo viene chiamata \textbf{TSG Grammar}. La grammatica TSG viene caricata da Tree Sitter Graph per costruire un oggetto manipolabile da Tree Sitter Stack Graph per costruire lo stack graph a partire dal codice.

Ad ogni occorrenza di nodo trovata dalla query viene applicato il blocco di codice appaiato, che puo' contenere istruzioni per costruire nodi, aggiungere archi, impostare variabili o aggiungere attributi.

I commenti in linea sono espressi tramite il prefisso ";;", e questo rappresenta l'unico modo di inserire dei commenti, visto non e' prevista una sintassi specifica per commenti multi linea.

\paragraph{variabili}
%TODO: let, var, set, FILEPATH, ROOT_NODE
%TODO: quote
Il linguaggio di scripting supporta l'uso di variabili, che possono essere locali, globali o di scope (associati ad un nodo sintattico).

Le variabili locali vengono dichiarate con l'uso di "let", e sono inerentemente immutabili:

\begin{verbatim}
(_) {
    let local_variable = "some value"
    set local_variable = "other" ;; ERROR
}
\end{verbatim}

Per dichiarare variabili locali mutabili e' necessario usare "var":

\begin{verbatim}
(_) {
    var local_variable = "some value"
    set local_variable = "other" ;; OK
}
\end{verbatim}

Le variabili globali devono essere dichiarate fuori dai blocchi di codice e non possono essere nascoste ("variable shadowing") dalle variabili locali:

\begin{verbatim}
global GLOBAL_VARIABLE

(_) {
    let GLOBAL_VARIABLE = "some" ;; ERROR
}
\end{verbatim}

Tree Sitter Stack Graph definisce due variabili globali: FILEPATH e ROOT\_NODE.

FILEPATH equivale al path corrente del file che sta venendo analizzato dall'engine e puo' risultare utile se si deve, per esempio, costruire un nodo nello stack graph corrispondente al file corrente per supportare la ricerca simbolica del codice importato nei linguaggi di programmazione il cui meccanismo di import dipende da path relativi (il caso di C++) piuttosto che da package o moduli (il caso di Java), o seppure nel secondo caso il nome del package corrente e' deciso dal nome del file (il caso di Python).

ROOT\_NODE invece e' sempre uguale ad un nodo di scope istanziato dallo stack graph stesso che ne costituisce la radice, e che e' utile poter manipolare nella grammatica TSG per collegare i sotto grafi generati dal singolo file sorgente per costruire un grafo unico incrementalmente.

\paragraph{nodi}
%TODO: node, node types, references, definitions

\paragraph{archi}
%TODO: edge

\paragraph{attributi}
%TODO: attr(node), attr(node -> node)

\paragraph{alias}
%TODO: shorthands

\paragraph{istruzioni condizionali}
%TODO: if - else

\paragraph{operazioni sulle stringhe}
%TODO: join, replace, path normalize

\paragraph{iterazioni}
%TODO: for each

\paragraph{debugging}
%TODO: print

\paragraph{complementi}
%TODO: debug attributes
