\chapter{Stack Graph}

\section{Introduzione}
%TODO: quote
Stack Graph e' un modello di grafo nato per risolvere il problema della navigazione simbolica del codice.
Attraverso la costruzione di un grafo con nodi detti di "scope", "push" e "pop" permette di effettuare una ricerca di una reference fino alla sua definizione.

Questa ricerca e' una vera e propria visita del grafo, che utilizza da una parte un Symbol Stack per tenere traccia dei simboli incontrati nella ricerca, e dall'altra tipi differenti di nodi visitabili che prescrivono come operare sul Symbol Stack e di conseguenza stabilire se un arco e' percorribile e se un percorso e' definito "completo".
Un percorso e' detto tale se e solo se il Symbol Stack e' svuotato.

Un nodo "push" inserisce un simbolo nel Symbol Stack quando e' attraversato dalla visita.
Vice versa un nodo "pop" rimuove un simbolo dal Symbol Stack.
In particolare questo limita gli archi percorribili in base a se e' possibile rimuovere il simbolo del nodo "pop".

\section{Esempio}
%TODO: esempio stupido del programma Java del capitolo precedente

\section{In Rust}
%TODO: codice per caricare la TSG e usare Stack Graph

\section{Domain Specific Language}

%TODO: quote
La libreria \textbf{Tree Sitter Stack Graph} funge da query engine per il Query Language definito da Tree Sitter e permette attraverso un linguaggio di scripting di costruire a runtime un grafo di tipo Stack Graph a partire da un file analizzato con Tree Sitter.

\paragraph{sintassi}

\begin{verbatim}
(tagA) {
    ;; code
}
\end{verbatim}

Ad ogni query tree sitter si accompagna un blocco di codice.
Un insieme di unita' siffatte e di dichiarazioni globali costituisce quella che in gergo viene chiamata \textbf{TSG Grammar}. La grammatica TSG viene caricata da Tree Sitter Graph per costruire un oggetto manipolabile da Tree Sitter Stack Graph per costruire lo stack graph a partire dal codice.

Ad ogni occorrenza di nodo trovata dalla query viene applicato il blocco di codice appaiato, che puo' contenere istruzioni per costruire nodi, aggiungere archi, impostare variabili o aggiungere attributi.

I commenti in linea sono espressi tramite il prefisso ";;", e questo rappresenta l'unico modo di inserire dei commenti, visto non e' prevista una sintassi specifica per commenti multi linea.
I commenti possono essere inseriti sia nei blocchi di codice che nel file della grammatica TSG in generale.

\paragraph{variabili}
Il linguaggio di scripting supporta l'uso di variabili, che possono essere locali, globali o di scope (associati ad un nodo sintattico).

Le variabili locali vengono dichiarate con l'uso di "let", e sono inerentemente immutabili:

\begin{verbatim}
(_) {
    let local_variable = "some value"
    set local_variable = "other" ;; ERROR
}
\end{verbatim}

Per dichiarare variabili locali mutabili e' necessario usare "var":

\begin{verbatim}
(_) {
    var local_variable = "some value"
    set local_variable = "other" ;; OK
}
\end{verbatim}

Una variabile di scope e' dichiarata in maniera simile. Essendo associata ad un nodo di query, puo' essere manipolata in piu' punti del codice.

\begin{verbatim}
(tagB)@B {
    let @B.scoped_variable = 17
}

(tagA (tagB)@B) {
    ;; @B.scoped_variable == 17
}
\end{verbatim}

Le variabili globali devono essere dichiarate fuori dai blocchi di codice e non possono essere nascoste ("variable shadowing") dalle variabili locali:

\begin{verbatim}
global GLOBAL_VARIABLE

(_) {
    let GLOBAL_VARIABLE = "some" ;; ERROR
}
\end{verbatim}

Tree Sitter Stack Graph definisce due variabili globali: FILE\_PATH e ROOT\_NODE.

FILE\_PATH equivale al path corrente del file che sta venendo analizzato dall'engine e puo' risultare utile se si deve, per esempio, costruire un nodo nello stack graph corrispondente al file corrente per supportare la ricerca simbolica del codice importato nei linguaggi di programmazione il cui meccanismo di import dipende da path relativi (il caso di C++) piuttosto che da package o moduli (il caso di Java), o seppure nel secondo caso il nome del package corrente e' deciso dal nome del file (il caso di Python).

ROOT\_NODE invece e' sempre uguale ad un nodo di scope istanziato dallo stack graph stesso che ne costituisce la radice, e che e' utile poter manipolare nella grammatica TSG per collegare i sotto grafi generati dal singolo file sorgente per costruire un grafo unico incrementalmente.

\paragraph{nodi}

Un nodo dello stack graph puo' essere dichiarato usando la funzione \textbf{node}.

\begin{verbatim}
(tagA)@this {
    node @this.a
    node b
}
\end{verbatim}

Ad ogni nodo e' associato un tipo impostabile con l'attributo "type" e di default uguale a "scope".
Un nodo di tipo "push" aggiunge il simbolo associato sul Symbol Stack durante la risoluzione delle reference, mentre un nodo di tipo "pop" ne rimuove uno dallo stack se e solo se il simbolo e' presente sulla cima dello stack, di fatto limitando i possibili percorsi della ricerca.

Esistono due attributi speciali che marcano i nodi di push/pop per applicare la semantica di uno stack graph: "is\_reference" e "is\_definition".
Un path completo ha come nodo di partenza un nodo "reference" e come nodo di arrivo un nodo "definition".
Un nodo reference e' un nodo push e un nodo definition e' un nodo pop.

\paragraph{archi}

Gli archi del grafo vengono dichiarati con una sintassi intuitiva.
Lo stack graph e' un grafo diretto, quindi la sintassi si propone di rappresentare proprio la direzione degli archi in maniera facilmente leggibile.

\begin{verbatim}
(_) {
    edge nodeA -> nodeB
}
\end{verbatim}

L'unico attributo che e' associabile ad un arco e' "precedence", ovvero un parametro intero utilizzato dall'algoritmo di ricerca di stack graph per implementare lo "shadowing" del codice.

\paragraph{attributi}

Per applicare un attributo ad un nodo o ad un arco si usa la seguente sintassi:

\begin{verbatim}
(_) {
    attr (nodeA)
        key = value,
        ...
    attr (nodeA -> nodeB)
        key = value,
        ...
}
\end{verbatim}

Come detto in precedenza, lo statement seguente dichiara che il nodo \emph{nodeA} e' una reference da risolvere con l'algoritmo di stack graph e che il simbolo da appendere e' quello corrispondente al pezzo di codice sorgente che il nodo rappresenta:

\begin{verbatim}
(_) {
    attr (nodeA)
        type = "push_symbol",
        node_symbol = nodeA,
        is_reference
}
\end{verbatim}

\paragraph{shorthands}
Puo' essere utile ricorrere a shorthands per evitare duplicazione nella grammatica TSG, specialmente se la formula e' sperimentale e/o si prevede che cambiera' per qualche motivo.

Gli shorthands sono disponibili solo per gli attributi, i quali rappresentano se non altro la parte piu' ridondante della grammatica, e che in altre circostanze costituirebbero uno Shotgun Surgery.

La sintassi e':

\begin{verbatim}
attribute name = input =>
    key = value,
    ...
\end{verbatim}

La dichiarazione di \emph{name} e' simile ad una funzione con un parametro \emph{input} manipolabile nelle coppie chiave valore.

L'uso pratico di questa feature puo' essere di due tipi: abbreviare un attributo per renderlo piu' facilmente leggibile o compattare una serie di attributi che ci si aspetta vengano dichiarati insieme piu' volte allo stesso modo. Un esempio puo' essere:

\begin{verbatim}
attribute
    defkind = kind =>
        debug_defkind = kind
attribute
    node_definition = node =>
        type = "pop_symbol",
        node_symbol = node,
        is_definition
\end{verbatim}

\paragraph{istruzioni condizionali}

Nel blocco di codice possiamo trovare anche le istruzioni condizionali, particolarmente utili dal momento che si dispone dei quantificatori nelle query.
Essi accettano una espressione come condizione, per esempio:

\begin{verbatim}
(tagA (tagB)?@id) {
    if some @id {
        ;; tagB presente
    } else {
        ;; tagB non presente
    }
}
\end{verbatim}

\paragraph{iterazioni}

Similarmente si possono usare le iterazioni sui nodi trovati dalla query coperti da quantificatore:

\begin{verbatim}
(tagA (tagB)*@ids) {
    for id in @ids {
        print id
    }
}
\end{verbatim}

\paragraph{operazioni sulle stringhe}

Essendo i simboli dell'albero sintattico stringhe, sono state implementate alcune funzioni nel linguaggio di scripting per manipolarle.

Nell'esempio seguente si risolve la locazione relativa di un modulo importato tramite l'istruzione \emph{include} del preprocessore C e si stampa a schermo il percorso completo:

\begin{verbatim}
(preproc_include path: (string_literal)@path) {
    let mod_name = (path-normalize
      (path-join
        (path-dir FILE_PATH)
        (replace (source-text @path) "\"" "")))
    print mod_name
}
\end{verbatim}

La funzione \emph{source-text} estrare la stringa contenuta nel nodo con identificatore \emph{path}, si applica la funzione replace per eliminare i doppi apici contenuti in essa e si risolve il path relativo utilizzando come base la directory del file corrente.
Quindi si chiama la funzione \emph{path-normalize} per ben formattare il path cosi' ottenuto.

\paragraph{debugging}

Per aiutare il programmatore nel debugging della grammatica TSG e' stata implementata una funzione \textbf{print} che stampa a schermo un valore.
Si puo' usare per esempio per visualizzare informazioni costruite dalla grammatica che si vuole inserire nel grafo.

In questo piccolo esempio si stampa a schermo la directory del file analizzato da Tree Sitter Stack Graph:

\begin{verbatim}
global FILE_PATH
(_) {
    print (path-dir FILE_PATH)
}
\end{verbatim}

\paragraph{complementi}

Oltre agli attributi supportati da Tree Sitter Stack Graph c'e' la possibilita' di assegnare attributi detti di "debug" che permettono di tenere traccia sia di informazioni puramente di testing sia informazioni utili al processamento dello Stack Graph per estrarre informazioni altrimenti impossibili da ottenere.

Per assegnare ad un nodo l'attributo di debug "varx" si usa la sintassi

\begin{verbatim}
(_) {
    attr (node)
        debug_varx = "value"
}
\end{verbatim}

Come detto precedentemente, e' utile poter definire ulteriori attributi che supportino l'analisi dello Stack Graph con algoritmi di esplorazione personalizzati.
Ai fini dell'analisi delle dipendenze si definiscono due variabili di debug:

\begin{itemize}
    \item "defkind"
    \item "refkind"
\end{itemize}

La prima definisce il tipo di definizione (classe, package, metodo ...), mentre la seconda il tipo di reference (estensione, uso di tipo in dichiarazioni di variabili, accesso a campo, chiamata di metodo ...).
