\chapter{Tree Sitter}

\section{Introduzione}

\textbf{Tree Sitter} \cite{tree_sitter} e' un software in grado di generare un parser (con lexer incorporato) per costruire l'Abstract Syntax Tree di un testo basandosi su un file di configurazione che descriva la grammatica del linguaggio considerato.

%TODO: quote
Il tool genera un parser in linguaggio \textbf{C} e del codice extra che funge da language binding in modo tale da poter chiamare il nuovo parser con un linguaggio di programmazione a piacere.

%TODO: quote
L'aspetto che piu' lo differenzia rispetto ai suoi competitori e' la possibilita' di fare analisi incrementali.
E' particolarmente efficiente quando si tratta di dover rianalizzare un file che ha subito delle modifiche.

%TODO: quote
E' in grado generare l'albero sintattico del nuovo file sorgente utilizzando come base l'albero sintattico obsoleto e una struttura dati che contiene le modifiche che ha subito il file nel suo complesso.

\section{In Rust}

Per utilizzare \textbf{tree sitter} in \textbf{rust} prima di tutto e' necessario importare delle dipendenze. Nel file Cargo.toml:

\begin{verbatim}
  [dependencies]
  tree-sitter = "*"
  tree-sitter-java = "*"
\end{verbatim}

%TODO: quote
Se si vuole utilizzare il parser tree sitter per il java per esempio si deve inserire tra le dipendenze \textbf{tree-sitter-java}.
In generale per un linguaggio \textbf{x} e' necessario importare ed utilizzare la libreria \textbf{tree-sitter-x}.
La lista dei linguaggi supportati e' disponibile sul sito del progetto Tree Sitter.

Quindi per utilizzare il parser del linguaggio \textbf{java} si usa il seguente snippet:

\begin{verbatim}
  let mut the_parser = tree_sitter::Parser::new();
  let the_language = tree_sitter_java::language();
  the_parser.set_language(the_language);
  let tree = the_parser.parse(the_text);
\end{verbatim}

La variabile \textbf{tree : tree\_sitter::Tree} conterra' l'albero generato da tree sitter.

%TODO: spiega come generare il tree con il diff

\section{Esempio}

Con il seguente file java:

\begin{verbatim}
class Main {
	public static void main(String[] args) {
    	// comment
    }
}
\end{verbatim}

si ottiene il seguente albero sintattico:

\begin{verbatim}
(program
  (class_declaration
    name: (identifier)
    body: (class_body
            (method_declaration
              (modifiers)
              type: (void_type)
              name: (identifier)
              parameters: (formal_parameters
                            (formal_parameter
                              type: (array_type
                                      element: (type_identifier)
                                      dimensions: (dimensions))
                              name: (identifier)))
              body: (block
                      (line_comment))))))
\end{verbatim}

\section{DSL}

%TODO: quote
L'albero sintattico e' graficamente rappresentato attraverso delle \textbf{sexp} che usano identificatori e struttura definiti dalla grammatica del linguaggio.
\textbf{Tree sitter} definisce un \textbf{Domain Specific Language} tramite il quale eseguire delle query ad un engine per ottenere tutte le occorrenze di un certo pattern strutturale.
Se le \textbf{sexp} utilizzate nelle query sono \textbf{language specific},  la sintassi generale del \textbf{DSL} e' universale.

%TODO: quote
Con l'apposita libreria \textbf{tree-sitter-stack-graphs} e' possibile fare delle query all'albero in DSL per generare un grafo qualsiasi a partire dall'AST.
In generale un query e' specificata in questo modo:

\begin{verbatim}
(parent_tag (child_tag)@child_tag_node)@parent_tag_node
\end{verbatim}

Questa query trova tutte le occorrenze di \textbf{parent\_tag} dove e' presente un \textbf{child\_tag} come figlio.
Si noti che questa query identifica un'occorrenza nel testo di \textbf{parent\_tag} una volta per ogni suo figlio di tipo \textbf{child\_tag}.

Ad ogni nodo dell'albero sintattico e' possibile associare un identificatore univoco all'interno della query, per esempio \textbf{@child\_tag\_node} identifica il nodo dell'AST \textbf{child\_tag}.

Ad ogni query e' possibile accompagnare un blocco di codice che specifica le operazioni da effettuare.
Ogni istruzione e' indicata in formato \textbf{function arg0 arg1 ...}.
La sintassi delle istruzioni richiama l'uso del paradigma funzionale, infatti essa e' molto simile a linguaggi che usano sexp per applicare delle funzioni, come per esempio \textbf{LISP}.

\begin{verbatim}
(parent_tag (child_tag)@child_tag_node)@parent_tag_node {
  node the_node
  attr (the_node) property = "value"
}
\end{verbatim}

La funzione \textbf{node} dichiara un nodo del grafo generato, mentre la funzione \textbf{attr} aggiunge attributi dal nodo del grafo.

\paragraph{proprieta' di nodi e archi}

Ad ogni nodo e' possibile accompagnare il tipo \textbf{type} che puo' assumere i seguenti valori:

\begin{itemize}
  \item "push\_symbol"
  \item "pop\_symbol"
\end{itemize}

Push e Pop sono le operazioni sul SymbolStack.
Questo stack e' utilizzato durante la ricerca dei name binding di uno stack\_graph.

In generale e' bene ricordare che una \textbf{push} deve essere associata ad un nodo di reference e una \textbf{pop} ad un nodo di definizione.

I nodi possono contenere anche informazioni "di debug", che nella pratica posso essere utilizzate per tenere traccia di tutta una serie di informazioni, come per esempio il tipo "semantico" di un nodo (classe, funzione ... etc) o anche per scopi di debug.
Per assegnare il valore \textbf{varname} ad un nodo si assegna con \textbf{attr} l'attributo \textbf{debug\_varname}.

Queste informazioni saranno accessibili da un programma che usa la libreria \textbf{stack-graphs} (richiesta da \textbf{tree-sitter-stack-graphs})

\paragraph{funzioni particolari}

La funzione \textbf{source-text} che dato un nodo AST restituisce la stringa che rappresenta quel nodo.
