\chapter{Tree Sitter}

Nel presente capitolo viene descritto Tree Sitter, il suo uso con Rust e il Query Language che definisce.

\section{Introduzione}

\textbf{Tree Sitter} \cite{TreeSitter} e' un software in grado di generare un parser (con lexer incorporato) per costruire l'Abstract Syntax Tree di un testo basandosi su un file di configurazione che descriva la grammatica del linguaggio considerato.

Il tool \cite{TreeSitterCreatingParsers} genera un parser in linguaggio \textbf{C} e del codice extra che funge da language binding in modo tale da poter chiamare il nuovo parser con un linguaggio di programmazione a piacere.
Il software generato e' privo di dipendenze, questo ne assicura la portabilita'.

L'aspetto che piu' lo differenzia rispetto ai suoi competitori e' la possibilita' di fare analisi incrementali \cite{TreeSitterAdvancedParsing}.
E' particolarmente efficiente quando si tratta di dover rianalizzare un file che ha subito delle modifiche.
E' in grado generare l'albero sintattico del nuovo file sorgente utilizzando come base l'albero sintattico obsoleto e una struttura dati che contiene le modifiche che ha subito il file nel suo complesso.

\section{In Rust}

Per utilizzare \textbf{tree sitter} in \textbf{rust} \cite{TreeSitterCrate} prima di tutto e' necessario importare delle dipendenze. Nel file Cargo.toml:

\begin{Verbatim}[samepage=true]
  [dependencies]
  tree-sitter = "*"
  tree-sitter-java = "*"
\end{Verbatim}

Se si vuole utilizzare il parser tree sitter per il java per esempio si deve inserire tra le dipendenze \textbf{tree-sitter-java}.
In generale per un linguaggio \textbf{x} e' necessario importare ed utilizzare la libreria \textbf{tree-sitter-x} \cite{TreeSitterRustGrammars}.
La lista dei linguaggi supportati e' disponibile sul sito del progetto Tree Sitter.

Quindi per utilizzare il parser del linguaggio \textbf{java} si usa il seguente snippet:

\begin{Verbatim}[samepage=true]
  let mut the_parser = tree_sitter::Parser::new();
  let the_language = tree_sitter_java::language();
  the_parser.set_language(the_language);
  let tree = the_parser.parse(the_text);
\end{Verbatim}

La variabile \textbf{tree : tree\_sitter::Tree} conterra' l'albero generato da tree sitter.

%TODO: spiega come generare il tree con il diff

\section{Esempio}

Con il seguente file java:

\begin{Verbatim}[samepage=true]
class Main {
	public static void main(String[] args) {
    	// comment
    }
}
\end{Verbatim}

si ottiene il seguente albero sintattico:

\begin{Verbatim}[samepage=true]
(program
  (class_declaration
    name: (identifier)
    body: (class_body
            (method_declaration
              (modifiers)
              type: (void_type)
              name: (identifier)
              parameters: (formal_parameters
                            (formal_parameter
                              type: (array_type
                                      element: (type_identifier)
                                      dimensions: (dimensions))
                              name: (identifier)))
              body: (block
                      (line_comment))))))
\end{Verbatim}

\section{Query Language}

L'albero sintattico e' graficamente rappresentato attraverso delle \textbf{sexp} che usano identificatori e struttura definiti dalla grammatica del linguaggio.
\textbf{Tree sitter} definisce un \textbf{Domain Specific Language} \cite{TreeSitterQuerySyntax} tramite il quale eseguire delle query ad un engine per ottenere tutte le occorrenze di un certo pattern strutturale.
Se le \textbf{sexp} utilizzate nelle query sono \textbf{language specific},  la sintassi generale del \textbf{DSL} e' universale.

Questo linguaggio di query puo' essere usato da un engine di query per implementare un linguaggio di scripting con cui permettere all'utente di operare in diversi modi su un file sorgente.
Con l'apposita libreria \textbf{tree-sitter-stack-graphs} e' possibile fare delle query all'AST per generare un grafo qualsiasi in modo strutturato usando il suo linguaggio di scripting, descritto in dettaglio nel prossimo successivo.

\subsection{sintassi}

\begin{Verbatim}[samepage=true]
(tagA (tagB (tagC)) (tagD))
\end{Verbatim}

Il query language non si discosta dalla rappresentazione in sexp.
Ogni nodo e' rappresentato tramite una sexp dove gli identificatori sono i nomi dei node dell'AST.
La stringa del testo a cui un nodo fa riferimento non e' esplicitamente contenuta ne' nella rappresentazione dell'AST, ne' nella query.
Un engine che applica delle query puo' fornire un'API per ottenere le informazioni corrispondenti ai nodi.

\subsection{field}

\begin{Verbatim}[samepage=true]
(tagA B: (tagB (tagC)) D: (tagD))
\end{Verbatim}

In una query e' possibile specificare i field del nodo che si vogliono riconoscere.
In questo modo e' possibile selezionare costrutti che per esempio fanno uso dei field per ordinare i valori in una sexp.
Si noti che l'accesso al field e' unico, ad ogni field e' associato al piu' un nodo.
Introdurre il field nella query esclude le occorrenze di tagA che non hanno per esempio associato un valore al field B.

\subsection{nodi anonimi}

\begin{Verbatim}[samepage=true]
(tagA "string")
\end{Verbatim}

Puo' risultare utile specificare al query engine una query siffatta.
Ad essa saranno associate tutte le occorrenze di tagA che contengano nodi la cui string nel testo sia uguale a "string".
E' importante sottolineare che la struttura del nodo associato a "string" puo' essere complessa a piacere.

\subsection{wildcard}

\begin{Verbatim}[samepage=true]
(tagA (_))
\end{Verbatim}

Un altro modo per specificare un nodo che con valore indefinito ma senza introdurre vincoli sulle stringhe del testo sono le wildcard.

\subsection{negatori}

\begin{Verbatim}[samepage=true]
(tagA !tagB)
\end{Verbatim}

E' anche possibile specificare field da non trovare nella sexp per definire un match.
Questa feature e' particolarmente rilevante quando si vuole dividere le query in casi per diminuire la complessita' del programma non dovendo fare affidamento su un unica query molto complessa e inutilmente generale.

\subsection{quantificatori}

\begin{Verbatim}[samepage=true]
(tagA (tagB)+ (tagC)? (tagD)*)
\end{Verbatim}

La negazione di un nodo fa parte di una categoria piu' grande, i quantificatori.
E' utile poter esprimere una query che raggruppi potenzialmente piu' nodi dello stesso tipo in un unico risultato, specialmente se l'engine permette di poter iterare sui nodi del risultato.
La semantica e' quella tipica delle espressioni regolari.

\subsection{identificatori}

\begin{Verbatim}[samepage=true]
(tagA (_)@child)@top
\end{Verbatim}

E' possibile associare ad ognun nodo del risultato della query un nodo utilizzando la notazione \emph{(node)@id}.
Se l'engine supporta linguaggi di scripting o strumenti affini torna utile potersi riferire ai singoli nodi.

\subsection{raggruppamenti}

\begin{Verbatim}[samepage=true]
(
  (tagA)
  (tagB)
)
\end{Verbatim}

Con questa sintatti si va a cercare una qualsiasi occorrenza nell'AST in cui i due nodi sono in sequenza e figli dello stesso nodo.
Questo significa pero' che vi possono essere nodi frapposti tra quelli elencati nella query.

\subsection{ancoramento}

\begin{Verbatim}[samepage=true]
(parent (child)@c1 . (child)@c2)
\end{Verbatim}

Un metodo di raggruppamento piu' forte e' il seguente.
Il carattere "." coincide con un operatore di concatenazione, e viene usato per esplicitare la posizione dei nodi all'interno di un nodo padre.
A differenza dei raggruppamenti semplici, qui il gruppo di nodi e' considerato in serie.
Non vi potranno essere nodi compresi tra quelli che corrispondono al match.

\begin{Verbatim}[samepage=true]
(parent . (child)@c1)
\end{Verbatim}

E' anche possibile esplicitare l'ancoramento rispetto ad un lato.
Per cui interporre l'operatore di concatenazione tra il parent tag e il nodo child permette di esplicitare che quel nodo child e' il primo nodo figlio del nodo parent.

\begin{Verbatim}[samepage=true]
(parent (child)@c1 .)
\end{Verbatim}

Allo stesso modo e' possibile indicare l'ultimo nodo figlio.

\subsection{alternative}

\begin{Verbatim}[samepage=true]
[
  (tagA)
  (tagB)
]@tag
\end{Verbatim}

Se in una query due nodi o configurazioni di nodi possono essere trattati allo stesso modo, puo' risultare utile comprimere la query con questo costrutto.
Come in un'espressione regolare, la query trova un'occorrenza in cui uno dei nodi tra le parentesi quadre combacia con quello reale.


\subsection{predicati}

\begin{Verbatim}[samepage=true]
(
  (parent
    (child)@A
    (child)@B
  )
  (#pred? @A @B)
)
\end{Verbatim}

Tree sitter descrive l'uso di alcuni predicati che permettono di asserire condizioni ulteriori di match.
I predicati implementati in pratica non fanno parte di uno standard, Tree Sitter si limita ad esporli ad un engine che a sua volta deve implementare e supportare il loro uso.

Nel caso proposto si applica un predicato \emph{pred} ai nodi argomenti \emph{A} e \emph{B}.
E' possibile anche usare come argomenti delle stringhe.
