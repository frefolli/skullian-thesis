\chapter{Introduzione}

In questo capitolo si descrive il contesto della ricerca, il problema affrontato e brevemente la soluzione proposta.

\section{Caso di studio - Arcan}

\paragraph{Ingegneria del Software}

Lo sviluppo del software \`e un processo lungo, complesso e spesso prono ad errori e fallimenti: sono innumerevoli i casi in cui un software diviene cos\`i complicato da sviluppare o gestire da venire abbandonato in favore di una nuova implementazione. Questo specialmente per il fatto che il processo di sviluppo non ha una data di fine se essa non coincide con la morte del software stesso. Il software deve essere aperto a cambiamenti e ottimizzazioni, i requisiti sono in continua evoluzione sia perch\'e il contesto \`e quello di un'economia capitalista in cui il focus \`e nell'espansione dei servizi e della portata degli stessi, sia perch\'e gli stessi servizi dipendono dai requisiti della societ\`a e delle attivit\`a umane, le quali soprattutto negli ultimi anni hanno dimostrato di essere in costante divenire. Qualora un software non potesse evolvere diventerebbe immediatamente obsoleto e quindi da una parte rimpiazzabile, dall'altra insoddisfacente.

\paragraph{Processi Software}

I processi impiegati per molto tempo hanno giocato un ruolo fondamentale nell'azzoppare il futuro splendore di un software: si pensi per esempio al Processo a Cascata \cite{larman2002applying}, il quale impedisce fino all'ultimo momento di valutare la reale utilit\`a di ci\`o che \`e stato implementato. Con la nascita dei metodi Agili \cite{larman2002applying} ci si \`e affrancati da processi che impedivano di osservare periodicamente la qualit\`a del software dal punto di vista tecnico / funzionale, di rianalizzare i requisiti del cliente e quindi di dirottare il processo verso nuovo pi\`u utili obiettivi. Inoltre si inizi\`o a mettere in risalto l'importanza della qualit\`a del software dal codice all'architettura.

\paragraph{Qualit\`a del Software}

Con gli anni sono nati progressivamente nuovi strumenti e framework che permettono di valutare la qualit\`a del software e di implementare fin da subito modelli orientati al riuso e all'espansione: si pensi per esempio ai Design Pattern \cite{gamma1995design} e ai \cite{fowler1999refactoring}. Ad oggi esistono strumenti che effettuano un'analisi basata su esecuzione simbolica del codice o sulla valutazione di alcune metriche, e che permettono di identificare in breve tempo devianze nello sviluppo del codice. Tuttavia le pi\`u importanti violazioni da osservare sono quelle nell'architettura di un software: spesso un design abbozzato e poco lungimirante porta a futuri guai sia nell'espansione dell'architettura, sia nell'implementazione dello stesso modello previsto. Per questo esistono una serie di strumenti che si prefiggono lo scopo di individuare questi problemi, detti \emph{Architectural Smell}, tramite l'analisi delle dipendenze di funzioni, package, classi e altre tipologie di componenti del codice: un esempio \`e Arcan \cite{Arcan}

\subsection{Arcan}

\paragraph{Tool Arcan}

Arcan \`e uno strumento che permette di rilevare le violazioni architetturali di un progetto software tramite l'analisi delle dipendenze delle sue componenti. Esso prima costruisce il Grafo delle Dipendenze, quindi lo esplora identificando pattern che suggeriscono Architectural Smells.

\putimage{diagrams/01/arcanDepgraph.png}{"Modello di Grafo delle Dipendenze costruito da Arcan - dal Manuale"}{fig:arcanDepgraph}
% TODO: grafo delle dipendenze

\putimage{diagrams/01/arcanSmells.png}{"Modello degli Architectural Smells costruito da Arcan - dal Manuale"}{fig:arcanSmells}
% TODO: grafo degli smell

\paragraph{Limitazioni Tecniche}

Allo stato attuale il tool Arcan, cos\`i come qualsiasi altro software che si serve del grafo delle dipendenze, utilizza software e librerie di terze parti per costruire tale grafo, uno per ogni linguaggio di programmazione. Il fatto di dover dipendere da vari software e installare molte librerie mina la scalabilit\`a orizzontale di un tool del genere: ogni nuova istanza avr\`a bisogno di notevole spazio di archiviazione per poter immagazzinare tutto il necessario per far funzionare Arcan.

Non \`e altrettanto vantaggioso dover dipendere da una tale variet\`a di software per ogni linguaggio da supportare: sia perch\'e non sempre \`e possibile trovare una libreria che permetta di analizzare staticamente il codice sorgente in quel linguaggio, si\`a perch\'e ogni collaborazione con un software diverso necessita talvolta di implementazioni distinte all'interno di Arcan, quindi aumentanto ulteriormente il peso dell'applicativo sia in memoria centrale che in memoria secondaria.

Altri aspetti da non sottovalutare sono l'efficacia della collaborazione tra Arcan e il software di terze parti, e l'efficienza stessa del software che analizza il codice sorgente. Per Java viene usato Eclipse JDT, una libreria facente parte del progetto Eclipse che effettua un'analisi statica del codice Java ed espone un API con cui richiedere informazioni sul sorgente; tuttavia per molti altri linguaggi di programmazione si \`e costretti a dipendere dai Language Server \cite{LanguageServer}, software notevolmente pi\`u impattanti sulle prestazioni che oltre alla semplice analisi statica effettuano in molti casi anche analisi dinamiche, simboliche e dinamiche. Per tutti questi motivi si \`e alla ricerca di metodo il pi\`u possibile language agnostic che permetta di ottenere gli stessi risultati con prestazioni migliori.

\section{Alcune tecnologie utili}

\paragraph{Rust}
Rust \cite{blandy2017programming} \`e un linguaggio di programmazione compilato e memory safe by design: utilizza un modello di gestione della memoria a "prestito" in modo da impedire memory leak e compilare ogni componente con la massima efficienza possibile. \`E stato scelto per implementare un prototipo sia per queste sue doti, sia perch\`e presenta alcune librerie interessanti da trattare ed utili ai fini del progetto.

\paragraph{Tree Sitter}
% TODO

\paragraph{Stack Graph}
% TODO

\paragraph{Tree Sitter Stack Graph}
% TODO

\section{La soluzione proposta}

\paragraph{Stack Graph}
% TODO

\paragraph{Name Resolution}
% TODO

\paragraph{Esplorazione Ricorsiva}
% TODO

\section{Valuzione dei risultati}

\paragraph{Benchmark}
% TODO

\paragraph{Scaffolding}
% TODO

\paragraph{Arcan}
% TODO

\section{Sommario dei Capitoli}
% TODO
