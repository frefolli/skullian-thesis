\chapter{Testing Framework}

In questo capitolo si descrive l'approccio di testing, le librerie e il materiale utilizzato per sviluppare il framework di test e alcuni criteri aggiuntivi di valutazione della qualit\`a relativamente alla soluzione adottata correntemente da Arcan.

\section{Approccio di Testing}

Per validare il processo di costruzione del grafo delle dipendenze ci si deve avvalere di uno o pi\`u meccanismi che permettano di verificare che le features dei linguaggi siano supportate, che tutte le relazioni e i nodi vengano identificati correttamente e che il processo riesca a scalare nella complessit\`a in termini di dimensione del codice.

\section{Scaffolding}

Si necessita la creazione di un meccanismo che verifichi il rispetto di politiche espresse in termini di contratti circa il risultato del grafo delle dipendenze. Questo \`e stato implementato direttamente nel software sviluppato: tramite una opportuna opzione da linea di comando si configura il test.

Ogni file contratto conterr\`a sia vincoli su nodi e relazioni, che indicazioni sui file da analizzare:

\begin{lstlisting}
filepaths:
    - file.java
nodes:
    - name: <qualified-name>
      kind: <defkind>
edges:
    - source: <qualified-name>
      sink: <qualified-name>
      kind: <relationship>
\end{lstlisting}

Il software legge usa i file indicati nel campo \emph{filepaths} per costruire il Grafo delle Dipendenze, quindi verifica uno a uno i vincoli specificati: per ogni vincolo di nodo che esista un nodo con quel nome e quel tipo, per ogni relazione che ne esista una tra i nodi specificati tramite i nomi.

Alla fine del processo di test il software tira le somme delineando il risultato, cosa manca e producendo in output un report collettivo, specialmente utile se si processano pi\`u test con lo stesso comando. Di seguito un esempio di report in formato Markdown:

\putimage{diagrams/06/testingReportExample.png}{"Esempio di Report di un contratto"}{fig:testingReportExample}

Esso appende inoltre nel report una tabella vuota per tenere traccia a mano dei problemi principali che \`e possibile inferire dal report e dalla conoscenza di cosa \`e stato implementato.

\putimage{diagrams/06/problemsReport.png}{"Esempio di Report di un contratto"}{fig:testingReportExample}

Grazie a questo strumento di testing si pu\`o adottare un approccio sistematico nell'implementazione delle grammatiche da una parte, e dell'algoritmo che costruisce il grafo dall'altra. Per tenere traccia delle operazioni e organizzare le implementazioni si puo' fare uso di uno strumento di Version Control come Git, specialmente se si lavora in team in parallelo. Nel caso corrente \`e stato utilizzato per gestire la versione in produzione affinch\`e non avesse implementazioni sperimentali o parziali.

\begin{lstlisting}[caption="Processo di implementazione", language=Python]
for language in SUPPORTED_LANGUAGES:
    # creazione ipotetica del fork del branch di sviluppo
    branch = forkBranch("development")
    # elencazione per enumerazione di tutte le features del linguaggio di
    # programmazione che siano utili ai fini delle relazioni da identificare o
    # che richiedano approcci ad hoc
    features = findLanguageFeatures()
    for feature in features:
        # costruzione di casi di test come coppia (sorgente, politica);
        # un numero di test adeguato rispetto alla variabilit\`a del costrutto e
        # alle possibili implicazioni rispetto ad altre relazioni gi\`a sviluppate
        buildTestFor(language, feature)
        # implementazione nella grammatica TSG e nel codice rust per introdurre
        # la rilevazione di nodi e archi del grafo delle dipendenze
        implementFeature(language, feature)
        # esecuzione di tutti i test fin'ora implementati per assicurarsi che
        # la nuova feature non vada ad interferire con le altre gi\`a presenti
        integrationTest()
        # salvare iterativamente i progressi permette di garantire la presenza
        # di un punto di ritorno sicuro nel caso si commetta qualche errore durante lo sviluppo
        commitBranch(branch)
    joinBranch("development", branch)
\end{lstlisting}

\section{Benchmark}

Oltre a test individuali per controllare il supporto delle singole caratteristiche, si fa uso anche di un framework per la verifica dell'identificazione delle dipendenze descritto in un paper di Leo Pruijt \cite{DBLP:journals/spe/PruijtKWB17} dove si tratta di valutazione dei sistemi di analisi statica delle dipendenze del codice.

\putimage{diagrams/06/directDependencies.png}{"Dipendenze dirette da rilevare nel codice"}{fig:directDependencies}

\putimage{diagrams/06/indirectDependencies.png}{"Dipendenze indirette da rilevare nel codice"}{fig:indirectDependencies}

Da queste tabelle il team di Arcan ha costruito una code base di esempio e quindi estratto una checklist di dipendenze legate alla code base che pu\`o essere utilizzata per accertare la capacit\`a di un tool di rilevare correttamente tutte le principali dipendenze del codice. Nella fase di validazione del software descritto in questi capitolo si fa uso della code base Java e della checklist, quest'ultima opportunamente tradotta in relazioni rilevabili dal modello in esame.

\section{Performace}

Oltre alla correttezza dell'analisi e' opportuno tenere traccia delle performance del software e delle grammatiche che vengono utilizzare per costruire il grafo, quindi non solo di valuta la velocit\`a con cui viene generato ma anche la quantit\`a di memoria che viene consumata e la scalabilit\`a del processo.
Per questo alternare test individuali con test pi\`u massivi per mette di stabilire quanto incide la complessit\`a di un progetto rispetto al tempo e alla spazio impiegati.
